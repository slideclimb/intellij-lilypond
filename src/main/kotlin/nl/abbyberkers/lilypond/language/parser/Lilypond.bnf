{
  parserClass="nl.abbyberkers.lilypond.language.parser.LilypondParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Lilypond"
  psiImplClassSuffix="Impl"
  psiPackage="nl.abbyberkers.lilypond.language.psi"
  psiImplPackage="nl.abbyberkers.lilypond.language.psi.impl"

  elementTypeHolderClass="nl.abbyberkers.lilypond.language.psi.LilypondTypes"
  elementTypeClass="nl.abbyberkers.lilypond.language.psi.LilypondElementType"
  tokenTypeClass="nl.abbyberkers.lilypond.language.psi.LilypondTokenType"

  tokens = [
    BACKSLASH='\'
    DIGIT="regexp:\d"
    DOT="."
    COMMA=","
    SINGLE_QUOTE="'"
    TILDE="~"
    BAR="|"
    SLASH="/"
    COLON=":"
    UNDERSCORE="_"
    PLUS="+"
    MINUS="-"
    STAR="*"
    HAT="^"
    QUESTION_MARK="?"
    EXCLAMATION_MARK="!"
    BACKTICK="`"

    EQUALS="="
    LEFT_BRACE="{"
    RIGHT_BRACE="}"
    LEFT_BRACKET="["
    RIGHT_BRACKET="]"
    LEFT_PAREN="("
    RIGHT_PAREN=")"

    MULTI_VOICE_START="<<"
    MULTI_VOICE_END=">>"
    SMALLER="<"
    GREATER=">"

    SCM_START="#"
    SCM_CONTINUE="#}"
    SCM_LILY_START="#{"
    SCM_START_DOLLAR="$"

    STRING_LITERAL="regexp:\"[^\"]*\""
    WHITESPACE="regexp:\s+"
    BLOCK_COMMENT="regexp:%\{(.|\n)*%}"
    LINE_COMMENT="regexp:%[^{].*"

    SCM_IDENTIFIER="regexp:[a-zA-Z-:]+"
    SCM_BLOCK_COMMENT="regexp:#!\{(.|\n)*!#"
    SCM_LINE_COMMENT="regexp:;.*"

    WORD="regexp:[^\s\\\{\}%\[\]$\(\)|!\"'=&<>,.]+"
  ]
}

// Parser is stupid and ridiculously simple on purpose. LilyPond allows almost anything, everywhere, so for now keep it simple
// and add complexity when it is useful for implementing a feature.
lilypondFile ::= (base_expression | BLOCK_COMMENT | LINE_COMMENT)*

base_expression ::= expression | braced_expression | scheme_expression

command ::= BACKSLASH WORD

braced_expression ::= LEFT_BRACE unit* RIGHT_BRACE {pin=3}

expression ::= unit+

unit ::= command
  | DIGIT
  | DOT
  | COMMA
  | SINGLE_QUOTE
  | TILDE
  | BAR
  | SLASH
  | BACKSLASH
  | COLON
  | UNDERSCORE
  | PLUS
  | MINUS
  | STAR
  | HAT
  | AMPERSAND
  | QUESTION_MARK
  | EXCLAMATION_MARK
  | EQUALS
  | LEFT_BRACE
  | RIGHT_BRACE
  | LEFT_BRACKET
  | RIGHT_BRACKET
  | LEFT_PAREN
  | RIGHT_PAREN
  | MULTI_VOICE_START
  | MULTI_VOICE_END
  | SMALLER
  | GREATER
  | string_lit
  | WORD

string_lit ::= QUOTE (STRING_LITERAL_CHAR | ESCAPED_QUOTE | ESCAPED_BACKSLASH)* QUOTE

// TODO implement https://www.scheme.com/tspl2d/grammar.html
// Scheme parser has to be implemented here. Language injection is not possible because of nesting (LilyPond in Scheme and vice versa)
// and references from/to both languages.
scheme_expression ::= (SCM_START | SCM_START_DOLLAR) scheme_expression_internal+

scheme_expression_internal ::= scm_function | scm_unit | SCM_BLOCK_COMMENT | SCM_LINE_COMMENT | scm_lily

scm_function ::= SCM_BACKTICK? (SCM_VECTOR_OPEN | SCM_LEFT_PAREN) scheme_expression_internal* SCM_RIGHT_PAREN

scm_id ::= (SCM_IDENTIFIER | SCM_PLUS | SCM_MINUS | SCM_SLASH | SCM_STAR)

scm_unit ::= SCM_COMMA
  | SCM_SINGLE_QUOTE
  | SCM_DOT
  | string_lit
  | SCM_SMALLER
  | SCM_GREATER
  | SCM_QUESTION_MARK
  | SCM_EXCLAMATION_MARK
  | SCM_EQUALS
  | SCM_AT
  | SCM_TRUE
  | SCM_FALSE
  | SCM_CHAR_START
  | ((SCM_HASH | SCM_SINGLE_QUOTE)? (scm_number | scm_id) (SCM_QUESTION_MARK | SCM_EXCLAMATION_MARK)?)

scm_number ::= SCM_MINUS? SCM_DIGIT+

scm_lily ::= SCM_LILY_START (base_expression | BLOCK_COMMENT | LINE_COMMENT)* SCM_CONTINUE


// more complicated version that has some problems (how to define `_6` in `\addScript _6 { a b c }`?)
//expression ::= command | assignment | multi_voice | music_line | time_signature | scheme_expression | IDENTIFIER | STRING_LITERAL
//
//assignment ::= IDENTIFIER EQUALS expression {pin=2}
//
//multi_voice ::= MULTI_VOICE_START expression* MULTI_VOICE_END {pin=3}
//
//music_line ::= (note | SLASH | chord | command | BAR)+
//
//time_signature ::= DIGIT+ SLASH DIGIT+ {pin=2}
//
//chord ::= CHORD_START (command | note)* CHORD_END modifiers? {pin=3}
//
//note ::= (PLUS | MINUS)? IDENTIFIER modifiers? (COLON SLASH? chord_mode_augmentation)?
//
//modifiers ::= (octave_modifier | duration_modifier | articulation | TILDE | LEFT_PAREN | RIGHT_PAREN | LEFT_BRACKET | RIGHT_BRACKET | PLUS | MINUS | SLASH | STRING_LITERAL | command)+
//
//duration_modifier ::= DIGIT DOT?
//
//octave_modifier ::= EQUALS? (SINGLE_QUOTE+ | COMMA+)
//
//articulation ::= MINUS (HAT | PLUS | MINUS | EXCLAMATION_MARK | CHORD_END | DOT | UNDERSCORE)
//
//chord_mode_augmentation ::= (IDENTIFIER | DIGIT | DOT | PLUS | MINUS | HAT | UNDERSCORE)+