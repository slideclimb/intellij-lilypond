{
  parserClass="nl.abbyberkers.lilypond.language.parser.LilypondParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Lilypond"
  psiImplClassSuffix="Impl"
  psiPackage="nl.abbyberkers.lilypond.language.psi"
  psiImplPackage="nl.abbyberkers.lilypond.language.psi.impl"

  elementTypeHolderClass="nl.abbyberkers.lilypond.language.psi.LilypondTypes"
  elementTypeClass="nl.abbyberkers.lilypond.language.psi.LilypondElementType"
  tokenTypeClass="nl.abbyberkers.lilypond.language.psi.LilypondTokenType"

  tokens = [

  ]
}

// notes
// - all <...>_IDENTIFIERs can be replaced with SCM_IDENTIFIER. Semantics don't matter for our purposes for now.
//   If they ever do, see scan_scm_id in LilyPonds lexer.ll and try_special_identifiers in their parser.yy.

lilypondFile ::= (toplevel_expression | assignment | BLOCK_COMMENT | LINE_COMMENT)*

toplevel_expression ::= header_block
//                   | book_block
//                   | bookpart_block
//                   | BOOK_IDENTIFIER
//                   | score_block
//                   | composite_music
//                   | full_markup
//                   | full_markup_list
//                   | SCM_TOKEN
//                   | embedded_scm_active
//                   | output_def

header_block ::= "\\header" '{' header_block_body '}'

header_block_body ::= (assignment | SCM_START | scheme_expression)*

assignment ::= assignment_id '=' identifier_init
             | assignment_id '.' property_path '=' identifier_init
             | markup_mode_word '=' identifier_init

assignment_id ::= string_lit | SYMBOL

identifier_init ::= identifier_init_nonumber
                  | number_expression
                  | symbol_list_part_bare '.' property_path
                  | symbol_list_part_bare ',' property_path
//                  | post_event_nofinger post_event*

identifier_init_nonumber ::= header_block
//                        | score_block
//                        | book_block
//                        | bookpart_block
//                        | output_def
//                        | context_def_spec_block
//                        | music_assign
//                        | pitch_or_music
//                        | FRACTION
                        | string_lit
//                        | embedded_scm
//                        | partial_markup
//                        | full_markup_list
//                        | context_modification
//                        | partial_function "\\etc"

property_path ::= symbol_list_rev

symbol_list_rev ::= symbol_list_part (('.' | ',') symbol_list_part)*

symbol_list_part ::= symbol_list_part_bare
                   | scheme_expression

symbol_list_part_bare ::= SYMBOL
                        | symbol_list_element

symbol_list_element ::= string_lit
                      | unsigned

unsigned ::= digit+
e_unsigned ::= BACKSLASH unsigned
fraction ::= unsigned SLASH unsigned
int ::= MINUS? unsigned
real ::= int DOT digit+

number_expression ::= number_term (('+' | '-') number_term)*

number_term ::= number_factor
              | number_factor '*' number_factor
              | number_factor '/' number_factor

number_factor ::= '-'* bare_number

bare_number ::= bare_number_common
              | unsigned SCM_IDENTIFIER?

bare_number_common ::= real
                     | SCM_IDENTIFIER
                     | real SCM_IDENTIFIER

markup_mode ::= "\\markup"

markup_mode_word ::= markup_mode markup_word

markup_word ::= string_lit
              | SYMBOL
// old lilypond
//base_expression ::= expression | braced_expression | scheme_expression
//
//command ::= BACKSLASH WORD
//
//braced_expression ::= LEFT_BRACE unit* RIGHT_BRACE {pin=3}
//
//expression ::= unit+
//
//unit ::= command
//  | DIGIT
//  | DOT
//  | COMMA
//  | SINGLE_QUOTE
//  | TILDE
//  | BAR
//  | SLASH
//  | BACKSLASH
//  | COLON
//  | UNDERSCORE
//  | PLUS
//  | MINUS
//  | STAR
//  | HAT
//  | AMPERSAND
//  | QUESTION_MARK
//  | EXCLAMATION_MARK
//  | EQUALS
//  | LEFT_BRACE
//  | RIGHT_BRACE
//  | LEFT_BRACKET
//  | RIGHT_BRACKET
//  | LEFT_PAREN
//  | RIGHT_PAREN
//  | MULTI_VOICE_START
//  | MULTI_VOICE_END
//  | SMALLER
//  | GREATER
//  | string_lit
//  | WORD

string_lit ::= QUOTE (STRING_LITERAL_CHAR | ESCAPED_QUOTE | ESCAPED_BACKSLASH)* QUOTE

// TODO implement https://www.scheme.com/tspl2d/grammar.html
// Scheme parser has to be implemented here. Language injection is not possible because of nesting (LilyPond in Scheme and vice versa)
// and references from/to both languages.
scheme_expression ::= (SCM_START | SCM_START_DOLLAR) scheme_expression_internal+

scheme_expression_internal ::= scm_function | scm_unit | SCM_BLOCK_COMMENT | SCM_LINE_COMMENT | scm_lily

scm_function ::= SCM_BACKTICK? (SCM_VECTOR_OPEN | SCM_LEFT_PAREN) scheme_expression_internal* SCM_RIGHT_PAREN

scm_id ::= (SCM_IDENTIFIER | SCM_PLUS | SCM_MINUS | SCM_SLASH | SCM_STAR)

scm_unit ::= SCM_COMMA
  | SCM_SINGLE_QUOTE
  | SCM_DOT
  | string_lit
  | SCM_SMALLER
  | SCM_GREATER
  | SCM_QUESTION_MARK
  | SCM_EXCLAMATION_MARK
  | SCM_EQUALS
  | SCM_AT
  | SCM_TRUE
  | SCM_FALSE
  | SCM_CHAR_START
  | ((SCM_HASH | SCM_SINGLE_QUOTE)? (scm_number | scm_id) (SCM_QUESTION_MARK | SCM_EXCLAMATION_MARK)?)

scm_number ::= SCM_MINUS? SCM_DIGIT+

scm_lily ::= SCM_LILY_START (base_expression | BLOCK_COMMENT | LINE_COMMENT)* SCM_CONTINUE


// more complicated version that has some problems (how to define `_6` in `\addScript _6 { a b c }`?)
//expression ::= command | assignment | multi_voice | music_line | time_signature | scheme_expression | IDENTIFIER | STRING_LITERAL
//
//assignment ::= IDENTIFIER EQUALS expression {pin=2}
//
//multi_voice ::= MULTI_VOICE_START expression* MULTI_VOICE_END {pin=3}
//
//music_line ::= (note | SLASH | chord | command | BAR)+
//
//time_signature ::= DIGIT+ SLASH DIGIT+ {pin=2}
//
//chord ::= CHORD_START (command | note)* CHORD_END modifiers? {pin=3}
//
//note ::= (PLUS | MINUS)? IDENTIFIER modifiers? (COLON SLASH? chord_mode_augmentation)?
//
//modifiers ::= (octave_modifier | duration_modifier | articulation | TILDE | LEFT_PAREN | RIGHT_PAREN | LEFT_BRACKET | RIGHT_BRACKET | PLUS | MINUS | SLASH | STRING_LITERAL | command)+
//
//duration_modifier ::= DIGIT DOT?
//
//octave_modifier ::= EQUALS? (SINGLE_QUOTE+ | COMMA+)
//
//articulation ::= MINUS (HAT | PLUS | MINUS | EXCLAMATION_MARK | CHORD_END | DOT | UNDERSCORE)
//
//chord_mode_augmentation ::= (IDENTIFIER | DIGIT | DOT | PLUS | MINUS | HAT | UNDERSCORE)+